---
title: "Testando Funções de Identificação"
author: ""
date: "24/11/2020"
output:
  word_document:
    reference_docx: modelo.docx
---
```{r, echo=FALSE}
#Carregamento de Bibliotecas
#Caso não tenha elas instaladas, rodar install.packages("pacote") antes

library(plyr)
library(magrittr)
library(readr)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggstatsplot)
library(RColorBrewer)
library(scales)
library(GGally)
library(pander)
library(rpart)
library(rpart.plot)
library(tidyverse)
library(lubridate)
library(tseries)
library(pracma) #Necessárias para a nls.lm (Levenberg Marquadt)
library(minpack.lm) #Necessárias para a nls.lm (Levenberg Marquadt)
```

Essa rotina foi criada para o teste do método STARIMA no R, desenvolvido para o Trabalho de Formatura: Aplicação de STARIMA para Previsão de Tráfego de Curto Prazo - Um Estudo de Caso na Av. 23 de Maio (AURÉLIO, M., DOMINGUES, K., TRINTINALIA, M., 2021), com base em Asaad (2013).

# CRIANDO OS DADOS TESTE

Outro modo de verificar o funcionamento da rotina na fase de identificação é gerar dados que sejam AR ou MA de ordens conhecidas:

```{r, echo=FALSE}
n_vizinhancas <- 4 #0 a n_radares-1
n_radares <- 4
n_timelags <- 1500
sigma2 <- 0.0001

radares <- c() #Para cabeçalho das tabelas
  for (i in 1:n_vizinhancas){
    radares[i] <- paste("R",i-1,sep="")
  }

ordens_vizinhanca <- c() #Para cabeçalho das tabelas
  for (i in 1:n_vizinhancas){
    ordens_vizinhanca[i] <- paste("L",i-1,sep="")
  }

# Zerando as variáveis
p <- 0
q <- 0
lambdap <- 0
lambdaq <- 0

# Criando matrizes espaciais
w_0 <- matrix(c(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),nrow=4,ncol=4)
w_1 <- matrix(c(0,0.5,0,0,1,0,0.5,0,0,0.5,0,1,0,0,0.5,0),nrow=4,ncol=4)
w_2 <- matrix(c(0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0),nrow=4,ncol=4)
w_3 <- matrix(c(0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0),nrow=4,ncol=4)

L <- list(w_0,w_1,w_2,w_3)

###########################
#ESCOLHA DO PROCESSO A SER TESTADO
processo <- readline("Que tipo de processo deseja gerar? (STAR/STMA/STARMA)?: ")
fim <- FALSE

while (fim == FALSE){
  if (processo == "STAR" | processo == "STMA" | processo == "STARMA"){
    fim <- TRUE
  } else {
    processo <- readline("Erro. Digite novamente, qual tipo de processo deseja gerar? (STAR/STMA/STARMA): ")
  }
}

# ESCOLHA DAS ORDENS

if (processo == "STAR" | processo == "STARMA"){
  p <- as.integer(readline("Qual a ordem temporal do modelo AR?: "))
  lambdap <- as.integer(readline("Qual a ordem espacial do modelo AR?: "))
  if (processo == "STAR"){
    q <- 0
    lambdaq <- 0
  }
}

if (processo == "STMA" | processo == "STARMA"){
  q <- as.integer(readline("Qual a ordem temporal do modelo MA?: "))
  lambdaq <- as.integer(readline("Qual a ordem espacial do modelo MA?: "))
  if (processo == "STMA"){
    p <- 0
    lambdap <- 0 
  }
}

#CRIANDO OS RUÍDOS

noise <- matrix(nrow=n_radares,ncol=(n_timelags+q))
for (i in 1:(n_timelags+q)){
  noise[,i] <- rnorm(n_radares,sd=sqrt(sigma2))
}

#CRIANDO OS DADOS

wstma <- matrix(0,nrow=n_radares,ncol=n_timelags)
for (t in 1:(n_timelags)){
  wstma[,t] <- noise[,t+q]
}

if (processo == "STMA" | processo == "STARMA"){
  #MODELO STMA
  alfas_teor <- matrix(nrow=q,ncol=lambdaq+1)
  
  for (m in 1:q){
    for (l in 0:lambdaq){
      alfas_teor[m,l+1]=(0.9/(q*(lambdaq+1)))*(0.9)^l*(0.9)^(m-1) #Quaisquer valores que mantenham o sistema estacionário (Pequenos o suficiente pra não causar problema Q?)
    }
  }
  
  for (t in 1:(n_timelags)){
    for (l in 0:lambdaq){
      for (m in 1:q){
        wstma[,t] <- wstma[,t]-alfas_teor[m,l+1]*L[[l+1]]%*%noise[,t-m+q]
      }
    }
  }
}


if (processo == "STAR" | processo == "STARMA"){
  #MODELO STAR
  
  betas_teor <- matrix(nrow=p,ncol=lambdap+1)
  
  for (k in 1:p){
    for (l in 0:lambdap){
      betas_teor[k,l+1] <- (0.7/(p*(lambdap+1)))*(0.5)^l*(0.5)^(k-1) #Em teoria pode ser qualquer número, desde que não seja muito grande (ideal manter menor do que 1, para que a série não cresça e deixe de ser estacionária). Colocamos betas decrescentes no tempo.
    }
  }
  
  w <- matrix(0,nrow=n_radares,ncol=n_timelags+p)
  w[,(p+1):(n_timelags+p)] <- wstma
  
  for (t in 1:(n_timelags+p)){
    for (l in 0:lambdap){
      for (k in 1:p){
        if ((t-k)>0){
          w[,t] <- w[,t]+betas_teor[k,l+1]*L[[l+1]]%*%w[,t-k]
        }
      }
    }
  }
  wstar <- w[,(p+1):(n_timelags+p)] #Dados Auto Regressivos de Ordens p e lambda
}


if (processo == "STARMA"){
  #MODELO STARMA
  wstarma <- wstar
}

#ATRIBUIÇÃO DOS PARÂMETROS A VARIÁVEIS
if (processo == "STAR"){
  tdados.mat <- wstar[,401:1400]
  tdados.mat_teste <- wstar[,1401:1500]
  ordem_espAR <- lambdap
  ordem_tempAR <- p
  ordem_espMA <- "NA"
  ordem_tempMA <- "NA"
  ordens <- c(p,lambdap,0,0)
  par_real <- matrix(betas_teor,nrow=1)
  fim <- TRUE
} else if (processo == "STMA"){
  tdados.mat <- wstma[,401:1400]
  tdados.mat_teste <- wstma[,1401:1500]
  ordem_espAR <- "NA"
  ordem_tempAR <- "NA"
  ordem_espMA <- lambdaq
  ordem_tempMA <- q
  ordens <- c(0,0,q,lambdaq)
  par_real <- matrix(alfas_teor,nrow=1)
  fim <- TRUE
} else if (processo == "STARMA"){
  tdados.mat <- wstarma[,401:1400]
  tdados.mat_teste <- wstarma[,1401:1500]
  ordem_espAR <- lambdap
  ordem_tempAR <- p
  ordem_espMA <- lambdaq
  ordem_tempMA <- q
  ordens <- c(p,lambdap,q,lambdaq)
  alfas_v <- matrix(alfas_teor,nrow=1)
  betas_v <- matrix(betas_teor,nrow=1)
  par_real <- cbind(alfas_v,betas_v)
  fim <- TRUE
}

#CRIAÇÃO DE LISTA DAS MATRIZES ESPACIAIS
W <- list(w_0,w_1,w_2,w_3)

```

Centralização dos dados - necessária para o uso das funções ACF e PACF:

```{r, echo=FALSE}
#RETIRANDO A MÉDIA
medias <- matrix(nrow=n_radares,ncol=1)
for (i in 1:n_radares){
    media <- mean(tdados.mat[i,])
    medias[i,1] <- media
    tdados.mat[i,]<-tdados.mat[i,]-media
}
```

Como são dados construídos do zero, nota-se que as médias são zero, ou muito próximas disso.

## Ordens da Média Móvel

### Space-Time Autocorrelation Function (STACF)

A função STACF é a que permite a definição das ordens q (temporal) e m (espacial) da média móvel.

```{r, echo=FALSE}
#DEFINIÇÃO DA FUNÇÃO
st.acf <- function(datamat,wmatrix1=NULL,wmatrix2=NULL,timelag=1,lwmat=FALSE,kwmat=FALSE){
  if (lwmat==TRUE & kwmat==TRUE){
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for(i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <- sumn + (wmatrix1[i,j])*(datamat[j,t])*(wmatrix2[i,j])*(datamat[j,t+(timelag)])
        }
      }
    }
    return(sumn/sqrt((sum((wmatrix1%*%datamat)^2))*(sum((wmatrix2%*%datamat)^2))))
  }
  else if (lwmat==TRUE & kwmat==FALSE){
    a=dim(datamat)[1] #n° de radares = N
    b=dim(datamat)[2] #n° de lags temporais = Tal
    #Timelag = s
    sumn <- 0
    for(i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <- sumn + (wmatrix1[i,j])*(datamat[j,t])*(datamat[i,t+(timelag)]) #Numerador
        }
      }
    }
    return(sumn/sqrt((sum((wmatrix1%*%datamat)^2))*(sum(datamat^2))))
    }
  else if (lwmat==FALSE & kwmat==TRUE){
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    
    sumn <- 0
    for (i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <-sumn + (datamat[i,t])*(wmatrix2[i,j])*(datamat[j,t+(timelag)])
        }
      }
    }
    
    return(sumn/sqrt((sum((datamat)^2))*(sum(wmatrix2%*%(datamat)^2))))
    
  }
  else{
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for(i in 1:a){
      for(t in 1:(b-(timelag))){
        sumn <- sumn + (datamat[i,t])*(datamat[i,t+(timelag)])
      }
    }
    return(sumn/sqrt((sum((datamat)^2))*(sum(datamat^2))))
    }
}

#################################
#APLICAÇÃO DA FUNÇÃO
timelags_acf <- 25

stacf_table<-matrix(nrow=timelags_acf+1,ncol=n_vizinhancas)

for (i in 0:timelags_acf){
  for (j in 0:(n_vizinhancas-1)){
    if (j == 0){
      stacf_table[i+1,j+1] <- st.acf(tdados.mat,timelag=i) #k=0 e l=0
    }else{
      stacf_table[i+1,j+1] <- st.acf(tdados.mat,wmatrix1=W[[j+1]],timelag=i,lwmat=TRUE) #k=0 e l=1, 2 e 3 
    }
  }
}

colnames(stacf_table) <- ordens_vizinhanca
knitr::kable(stacf_table)
```

## Ordens da Auto Regressão

### Space-Time Auto Covariance Function (STACOVF)
A função STACOVF é utilizada na estimação da função STPACF (que por sua vez define as ordens p e lambda da Auto Regressão), por meio do análogo espaço temporal à equação de Yule Walker.

Assim, para cada lag temporal k e ordem espacial l, haverá um sistema diferente de equações a ser resolvido, com os valores de phi como as incógnitas. Para a STPACF, no entanto, apenas os valores de `r phi sub k,l` interessam. 

```{r, echo=FALSE}
#DEFINIÇÃO DA FUNÇÃO
st.acovf <- function(datamat,wmatrix1=NULL,wmatrix2=NULL,timelag=1,lwmat=FALSE,kwmat=FALSE){
  if (lwmat==TRUE & kwmat==TRUE){
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for(i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <- sumn + (wmatrix1[i,j])*(datamat[j,t])*(wmatrix2[i,j])*(datamat[j,t+(timelag)])
        }
      }
    }
    return(sumn/(a*(b-(timelag))))
  }
  else if (lwmat==TRUE & kwmat==FALSE){
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for(i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <- sumn + (wmatrix1[i,j])*(datamat[j,t])*(datamat[i,t+(timelag)])
        }
      }
    }
    return(sumn/(a*(b-(timelag))))
    }
  else if (lwmat==FALSE & kwmat==TRUE){
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for (i in 1:a){
      for(j in 1:a){
        for(t in 1:(b-(timelag))){
          sumn <-sumn + (datamat[i,t])*(wmatrix2[i,j])*(datamat[j,t+(timelag)])
        }
      }
    }
    return(sumn/(a*(b-(timelag))))
  }
  else{
    a=dim(datamat)[1]
    b=dim(datamat)[2]
    sumn <- 0
    for(i in 1:a){
      for(t in 1:(b-(timelag))){
        sumn <- sumn + (datamat[i,t])*(datamat[i,t+(timelag)])
      }
    }
    return(sumn/(a*(b-(timelag))))
    #return(sumn/(a*b))
    }
}
#######################################
#APLICAÇÃO DA FUNÇÃO

timelags_pacf <- 5 #Começar com timelags pequenos, pois trata-se de um processo computacionalmente custoso

stpacf_table <- matrix(nrow=timelags_pacf,ncol=n_vizinhancas)

#Para cada timelag e cada spatial lag da stpacf, deve-se resolver um sistema de Yule Walker diferente:

for (tau in 1:timelags_pacf){
  for (lambda in 0:(n_vizinhancas-1)){
    
    #Lado esquerdo do sistema de equações Yule Walker
    #Para cada timelag s, deve-se fazer as combinações de k e l, que devem variar de 0 a 2. Note que quando uma das variáveis k ou l for igual a 0, não há a necessidade de colocar a matriz espacial como input (visto que o operador espacial de ordem 0 é uma matriz identidade)
    Y.mat <- matrix(nrow=tau*(lambda+1),ncol=1)
    # Para L igual a 0 e K variando de 0 a 3
    for (i in 1:tau){
      for (j in 0:(lambda)){
        if (j == 0){
          Y.mat[(i-1)*(lambda+1)+1,1] <- st.acovf(tdados.mat,timelag=i)#k=0 e l=0 
        }else{
          Y.mat[(i-1)*(lambda+1)+j+1,1] <- st.acovf(tdados.mat,timelag=i,wmatrix1=W[[j+1]],lwmat=TRUE) #k=0 e l= 1, 2 e 3 
        }
      }
    }
    
    # Agora montando a matriz A
    #Inicialmente, montamos as submatrizes
    submatrizes <- list()
    for (i in 0:(tau-1)){
      submat <- matrix(nrow=(lambda+1),ncol=(lambda+1))
      for (k in 0:(lambda)){
        for (l in 0:(lambda)){
          if (k==0 & l==0){
            submat[k+1,l+1] <- st.acovf(tdados.mat,timelag=i) #k=0 e l=0
          } else if (k==0){
            submat[k+1,l+1] <- st.acovf(tdados.mat,timelag=i,wmatrix1=W[[l+1]],lwmat=TRUE) #k=0 e l=1,2,3
          } else if (l==0){
            submat[k+1,l+1] <- st.acovf(tdados.mat,timelag=i,wmatrix2=W[[k+1]],kwmat=TRUE) #l=0 e k=1,2,3
          } else{
            submat[k+1,l+1] <- st.acovf(tdados.mat,timelag=i,wmatrix1=W[[l+1]],wmatrix2=W[[k+1]],lwmat=TRUE,kwmat=TRUE) #k=1,2,3 e l=1,2,3 
          }
        }
      }
      submatrizes[[i+1]] <- submat
    }
    
    A.mat <- matrix(nrow=tau*(lambda+1),ncol=tau*(lambda+1))
    
    for (i in 0:(tau-1)){
      for (j in 0:(tau-1)){
        ind <- abs(i-j)
        submat <- submatrizes[[ind+1]]
        for (k in 1:(lambda+1)){
          for (l in 1:(lambda+1)){
            A.mat[i*(lambda+1)+k,j*(lambda+1)+l]<-submat[k,l]
          }
        }
      }
    }
    
    #Resolução da equação de Yule Walker, retornando os parâmetros de PACF estimados:
    A.matinv <- solve(A.mat)
    Est <- A.matinv%*%Y.mat
    
    Est.mat <- matrix(Est,nrow=tau,ncol=(lambda+1),byrow=TRUE)
    stpacf_table[tau,(lambda+1)] <- Est.mat[tau,(lambda+1)] #PACF pega apenas o último valor da Est.mat, para cada timelag e spatial lag considerado
  }
}

colnames(stpacf_table) <- ordens_vizinhanca
knitr::kable(stpacf_table)

```

## Plotagem


A identificação das ordens do modelo (temporais e espaciais, tanto para AR quanto para MA) são feitas a partir da STACF e STPACF.

O gráfico abaixo representa, para cada timelag, a correlação entre os diferentes pontos espaciais. Assim, para determinado timelag, o valor no gráfico indica quanto cada ponto influência o ponto previsto (incluindo o próprio analisado).

Assim, para definir a ordem temporal basta identificar o último timelag com valor acima do ruído, para a linha de L0. E para a ordem espacial basta identificar quantas (se houver) linhas além da L0 que apresentam valores acima do ruído.

Relembrando que o gráfico da STACF serve para a identificação de q (temporal) e m (espacial), e a STPACF serve para identificar p (temporal) e lambda (espacial).


```{r, echo=FALSE}
par(cex.main = 0.85) #Tamanho do título
par(cex.axis = 0.95)

stacf_plot <- as.data.frame(abs(stacf_table))
stacf_plot <- rownames_to_column(stacf_plot)
colnames(stacf_plot) = c("Timelag","L0","L1","L2","L3")
stacf_plot <- stacf_plot %>% mutate(Timelag = as.integer(Timelag), Timelag = Timelag-1)

cores <- hcl.colors(n_vizinhancas, palette = "viridis", alpha = NULL, rev = FALSE, fixup = TRUE)
plot(stacf_plot$Timelag,stacf_plot[,2],type="l",col=cores[1],main = "STACF do Processo", xlab = "Timelags", ylab="STACF",ylim=c(0,1))
for (i in 2:n_vizinhancas){
  lines(stacf_plot$Timelag,stacf_plot[,i+1],col=cores[i])
}
legend(x = 20, y = 1, legend = ordens_vizinhanca, col = cores,lty=1:2, cex=0.95)
axis(1, seq(0,timelags_acf,1))

# ------------------------------

stpacf_plot <- as.data.frame(abs(stpacf_table))
stpacf_plot <- rownames_to_column(stpacf_plot)
colnames(stpacf_plot) = c("Timelag","L0","L1","L2","L3")
# obs0 <- c(0,1,NA,NA,NA) #Coloca um valor unitário no timelag 0, para melhorar a escala de observação
# stpacf_plot <- rbind(obs0,stpacf_plot)

#obs0 <- c(0,1,NA,NA,NA)
#stpacf_plot <- rbind(obs0,stpacf_plot)

cores <- hcl.colors(n_vizinhancas, palette = "viridis", alpha = NULL, rev = FALSE, fixup = TRUE)
plot(stpacf_plot$Timelag,stpacf_plot[,2],type="l",col=cores[1],main = "STPACF do Processo", xlab = "Timelags", ylab="STPACF",ylim=c(0,max(abs(stpacf_table))))
for (i in 2:n_vizinhancas){
  lines(stpacf_plot$Timelag,stpacf_plot[,i+1],col=cores[i])
}
legend(x = 4, y = 0.08, legend = ordens_vizinhanca, col = cores,lty=1:2, cex=0.95)
axis(1, seq(0,timelags_acf,1))
```

Conclusões:
Ao testar para bancos de dados extensos (1000 timelags para cima), tanto STACF quanto STPACF indicam correta e claramente as ordens espaciais e temporais de AR e MA, para processos STAR e STMA.
No entanto, para processos STARMA já se torna confusa a visualização dessas ordens, indicando que a rotina está implementada corretamente, mas o método em si da identificação dos parâmetros não é tão preciso, dando apenas certo direcionamento.

Além disso, uma mudança do banco de dados para menos timelags (480, por exemplo, que é o caso do banco de dados utilizado no TCC da Av. 23 de Maio), até mesmo a identificação de modelos STAR e STMA se torna difícil.

# ESTIMAÇÃO DOS PARÂMETROS

Determinadas as ordens espaciais e temporais, deve-se agora definir os parâmetros alfas e betas.
Caso seja um processo STAR, a resolução passa por um sistema linear. No entanto, nos casos de processos STARMA ou STMA, o caso é não linear.

Para resolver a questão, o artigo de ASAAD sugere o uso do algoritmo de Levenberg Marquadt, mas detacamos que existem outros métodos de solução não lineares que podem ser empregados, a critério do usuário.

Para resolver o Levenberg Marquadt, cuja função já existe no R, é necessário o input dos dados temporais, uma estimativa inicial dos parâmetros e uma função a ser estimada (No caso, a chamada RSTARIMA, que calcula o resíduo).

Como output, a função retorna o número de iterações feitas, os parâmetros utilizados em cada iteração e o erro obtido com o uso desses parâmetros.

Sendo assim, inicialmente é necessário definir a função RSTARIMA (que nada mais é que o cálculo do resíduo entre o calculado pelo STARIMA e o ocorrido de fato).

Ao montar a equação STARIMA para as ordens definidas, verifica-se que são necessários os valores das p observações anteriores, e dos q resíduos anteriores para o cálculo.

Sendo assim, para que possamos aplicar o método Levenberg Marquadt seria necessário primeiramente obtermos os valores passados dos resíduos - fazer um 'backforecasting'.

No entanto, devido à hipótese de ruído branco para os resíduos, pode-se admitir que esses valores passados são zero, sem grandes prejuízos para o método. A função RSTARIMA abaixo considera que esses valores passados são zero:

```{r, echo=FALSE}
#DEFINIÇÃO DA FUNÇÃO RSTARIMA

RSTARIMA <- function(par, datamat, wmatrix, ordens){
  # Recebe uma lista de parâmetros os dados temporal-espaciais, a lista de matrizes espaciais e a lista de ordens do modelo.
  # A diferença entre essa função e a STARIMA é que essa calcula já os resíduos, considerando que os primeiros (ou seja, aqueles que precisariam ser calculados por backforecasting) são zero.
  #datamat no formato n x t
  
  #Transformando o vetor de parâmetros em matrix linha
  par <- matrix(par,nrow=1)

  #Pegando as ordens
  p <- ordens[1]
  lambda <- ordens[2]
  q <- ordens[3]
  m <- ordens[4]
  
  #Criando a matriz de parâmetros a partir do vetor fornecido
  if (q>0){
    alfas <- matrix(par[1:((m+1)*q)],ncol=(m+1), nrow=q) #par de 1 a [(m+1) * q]
    #print(paste("ALFAS: \n",alfas))
  }
  if (p>0){
    betas <- matrix(par[((m+1)*q+1):length(par)],ncol=(lambda+1), nrow=p) #par de [(m+1) * q] até o final - total de lambda+1 * p
    #print(paste("BETAS: \n",betas))
  }
  
  tmax <- length(datamat[1,]) #Máximo número de timelags no banco de dados
  n_radares <- length(datamat[,1]) #Número de radares do banco de dados
  
  residuos <- matrix(0,nrow=n_radares, ncol=tmax) #Matriz zerada de n_radares x tmax
  
  for (t in (1+max(p,q)):tmax){
    residuos[,t] <- datamat[,t]
    
    if (p>0){
      for (k in 1:p){
        for (l in 0:lambda){
          residuos[,t] <- residuos[,t] - betas[k,l+1] * (wmatrix[[l+1]] %*% datamat[,t-k])
        }
      }
    }
    
    if (q>0){
      for (k in 1:q){
        for (l in 0:m){
          residuos[,t] <- residuos[,t] + alfas[k,l+1] * (wmatrix[[l+1]] %*% residuos[,t-k])
        }
      }
    }
  }
  
  residuos <- as.vector(residuos)
  return (residuos)
}

```

Tendo a função, podemos seguir para a estimação.
De acordo com os valores de p, lambda, q e m, sabemos quantos parâmetros alfa e beta devem ser estimados (da equação do STARIMA):
Nbeta = (lambda+1) * p
Nalfa = (m+1) * q

A estimação dos parâmetros segue um processo iterativo de cálculo, que varia os parâmetros alfas e betas, jogando-os na função STARIMA e buscando minimizar o resíduo.

Como se trata de um processo iterativo, é necessário um chute inicial dos parâmetros, que pega valores pico das funções STACF e STPACF:

```{r, echo=FALSE}
# CHUTES INICIAIS DE ALFAS E BETAS

#Asaad usou os valores significantes que resultaram da stacf e da stpacf, em ordem de maior módulo e atribuiu nessa ordem para os parâmetros iniciais.

#O chute inicial dos coeficientes autorregressivos vem dos resultados da função STPACF
if (p>0){
  #Lista de parâmetros autoregressivos
  #Criando uma cópia da stpacf_table 
  stpacf_abs_table <- matrix(0, nrow=dim(stpacf_table)[1], ncol=dim(stpacf_table)[2])
  stpacf_abs_table <- stpacf_table 
  
  #ordenando cada coluna de acordo com os valores significantes e transformando em matrix
  b <- matrix(0,nrow=dim(stpacf_table)[1], ncol=dim(stpacf_table)[2])
  
  for (i in 1:dim(stpacf_table)[2]){
    b[,i] <- stpacf_abs_table[,i][order(-abs(stpacf_abs_table[,i]))] #Pega os valores e ordena cada coluna de acordo com o maior valor em módulo
  }
  
  betas <- matrix(ncol=(lambdap+1), nrow=p)
  #Retira somente o número de parâmetros necessários, após ser reoordenado
  for (i in 1:p){
    for (j in 1:(lambdap+1)){
     betas[i,j] <- b[i,j]
    }
  }
  par_betas <- matrix(betas,nrow=1)
} else {
    par_betas <- NULL
}

#O chute inicial dos coeficientes de médias móveis vem dos resultados da função STACF
if (q>0){
  #Lista de parâmetros de média móvel
  #Criando uma cópia da stpacf_table
  stacf_abs_table <- matrix(0, nrow=dim(stacf_table)[1]*dim(stacf_table)[2],ncol=1)
  stacf_abs_table <- stacf_table 
  
  #ordenando de acordo com os valores significantes e transformando em matrix
  c <- matrix(0,nrow=dim(stacf_table)[1], ncol=dim(stacf_table)[2])
  stacf_abs_table[1,1] <- 0
  
  for (i in 1:dim(stacf_table)[2]){
    c[,i] <- stacf_abs_table[,i][order(-abs(stacf_abs_table[,i]))] #Pega os valores e ordena cada coluna de acordo com o maior valor em módulo
  }
  
 alfas <- matrix(ncol=(lambdaq+1), nrow=q)
 #Retira somente o número de parâmetros necessários, após ser reoordenado
  for (i in 1:q){
    for (j in 1:(lambdaq+1)){
      alfas[i,j] <- c[i,j]
    }
  }
  
  par_alfas <- matrix(alfas,nrow=1)
} else {
  par_alfas <- NULL
}

par <- cbind(par_alfas,par_betas)
par <- as.vector(par)
par <- abs(par)
```

É importante notar que não se utiliza o primeiro valor da STACF, que é sempre unitário, pois esse chute inicial pode causar uma divergência do processo de estimação.

Tendo os valores das observações, a função que calcula os resíduos passados e o chute inicial dos parâmetros, pode-se finalmente aplicar a função de Levenberg Marquadt:

```{r, echo=FALSE}

nls.out <- nls.lm(fn = RSTARIMA,par=par,datamat = tdados.mat, wmatrix=W, ordens=ordens,control=nls.lm.control(nprint=10))

#Parâmetros estimados pela Levenberg
par_est <- nls.out$par
par_est <- matrix(par_est,nrow=1)
```


```{r,echo=FALSE}
print("Parâmetros Reais")
print(par_real)
####################
print("Chute Inicial")
print(par)
####################
print("Parâmetros estimados")
print(par_est)
```

```{r, echo=FALSE}
teste_RSTARIMA_real <- RSTARIMA(par=par_real,datamat = tdados.mat, wmatrix=W, ordens=ordens)
teste_RSTARIMA_real <- sum(teste_RSTARIMA_real^2)
teste_RSTARIMA_est <- RSTARIMA(par=par_est,datamat = tdados.mat, wmatrix=W, ordens=ordens)
teste_RSTARIMA_est <- sum(teste_RSTARIMA_est^2)

print(paste("RSS para os parâmetros estimados: ", round(teste_RSTARIMA_est,6)))
print(paste("RSS para os parâmetros reais: ", round(teste_RSTARIMA_real,6)))

```

O teste da estimação é feito para os casos de processos: AR, MA, ARMA, STAR, STMA e STARMA, de ordens variadas (para maiores detalhes, verificar o arquivo Excel com todos os testes realizados). Para cada caso, deve-se verificar o erro relativo entre parâmetros reais e parâmetros estimados; o RSS com os parâmetros reais (que deve ser aproximadamente 0,1 * n_radares); e o RSS com os parâmetros estimados (que deve ser próximo ao RSS com os parâmetros reais). Satisfeitas essas verificações, pode-se afirmar que a estimação de parâmetros está funcionando.

Para alguns casos mais complexos (junção de AR com MA ou junção com a questão espacial), o erro relativo dos parâmetros pode ser ruim, porém isso é aceitável até certo grau, pois trata-se de valores muito pequenos, fazendo com que o erro relativo acabe sendo alto mesmo para pequenas variações.

A impressão dos valores dos chutes iniciais serve para, uma vez verificado o funcionamento da estimação de parâmetros, verificar qual a influência da variação do chute inicial nessa estimação. Porém, nota-se com os testes que pequenas variações não exercem grande influência na estimação, contanto que haja o cuidado para que os chutes não sejam maiores que 1, pois isso faz com que o sistema divirja.


```{r, echo=FALSE}

Residuo_RSTARIMA <- RSTARIMA(par=par_real,datamat = tdados.mat, wmatrix=W, ordens=ordens)
Residuo_Real <- as.vector(noise[,(length(noise[1,])-1000):length(noise[1,])])

Residuo_RSTARIMA <- as.data.frame(Residuo_RSTARIMA)
Residuo_RSTARIMA <- rownames_to_column(Residuo_RSTARIMA,var="Timelag")

Residuo_Real <- as.data.frame(Residuo_Real)
Residuo_Real <- rownames_to_column(Residuo_Real,var="Timelag")

plot(Residuo_RSTARIMA$Timelag,Residuo_RSTARIMA$Residuo_RSTARIMA,type="l",col="red", main = "Residuos", xlab = "Timelags", ylab="Resíduos")
lines(Residuo_Real$Timelag,Residuo_Real$Residuo_Real,col="skyblue")
#axis(1, seq(0,timelags_acf,1))
legend(x = 20, y = 1, legend = c("RSTARIMA","Real"), col = c("red","skyblue"),lty=1:2, cex=0.95)

```

Pelo modo como foi construída a RSTARIMA, os resíduos calculados devem ser iguais (ou muito próximos, devido a erros de cálculo computacionais) aos resíduos reais utilizados para a construção do processo, a partir de dado instante - visto que nos instantes iniciais obviamente será bem diferente, pois foi admitido o valor 0, para simplificar o processo, quando na realidade seria necessário um backforecasting.

Observa-se pelo gráfico que isso é verdade, indicando que a RSTARIMA está funcionando corretamente.

# CALIBRAÇÃO DO MODELO

Segue-se então para a calibração do modelo, que consiste em utilizar a construção feita até aqui (determinação das ordens e parâmetros) e aplicar aos dados de treino, verificando os resíduos.
Serão utilizados neste trabalho os seguintes indicadores de acurácia para a calibração do modelo:

```{r, echo=FALSE}

#DEFINIÇÃO DA FUNÇÃO QUE CALCULA OS COEFICIENTES DE ACURÁCIA
coef_acur <- function(observado,residuo,stacf_res){
  
  boxpierce <- length(stacf_res) * sum(stacf_res^2)
  
  rss <- sum(residuo^2)
  efic <- 1-(rss/sum((observado - mean(observado))^2))
  mae <- sum(abs(residuo))/length(residuo)
  
  coef <- matrix(c("E","RSS","MAE","Box-Pierce",efic,rss,mae,boxpierce),nrow=2,ncol=4,byrow=TRUE)
  return(coef)
}

```

Tendo-se a função, parte-se para sua aplicação aos dados de treino:

```{r, echo=FALSE}
#PARÂMETROS ESTIMADOS
#Resíduos para calibração
residuos_cal <- matrix(RSTARIMA(par=par_est,datamat=tdados.mat,wmatrix=W,ordens=ordens),nrow=n_radares)
lags_cal <- max(ordens[1],ordens[3])
residuos_cal <- residuos_cal[,(lags_cal+1):length(residuos_cal[1,])] #Descarta os primeiros resíduos, que são 0 devido à falta do backforecasting

#PARÂMETROS REAIS
#Resíduos para calibração
residuos_cal_r <- matrix(RSTARIMA(par=par_real,datamat=tdados.mat,wmatrix=W,ordens=ordens),nrow=n_radares)
residuos_cal_r <- residuos_cal_r[,(lags_cal+1):length(residuos_cal_r[1,])] #Descarta os primeiros resíduos, que são 0 devido à falta do backforecasting

#OBSERVAÇÕES PARA CALIBRAÇÃO
observado_cal <- tdados.mat[,(lags_cal+1):length(tdados.mat[1,])]

###########################
#Cálculo da STACF dos resíduos com parâmetros estimados
timelags_acf_res <- 25 #Número de timelags de cálculo da função

stacf_res_table<-matrix(nrow=timelags_acf_res+1,ncol=n_vizinhancas)

for (i in 0:timelags_acf_res){
  for (j in 0:(n_vizinhancas-1)){
    if (j == 0){
      stacf_res_table[i+1,j+1] <- st.acf(residuos_cal,timelag=i) #k=0 e l=0
    }else{
      stacf_res_table[i+1,j+1] <- st.acf(residuos_cal,wmatrix1=W[[j+1]],timelag=i,lwmat=TRUE) #k=0 e l=1, 2 e 3 
    }
  }
}

stacf_res_table <- as.vector(stacf_res_table)
stacf_res_table <- stacf_res_table[2:length(stacf_res_table)] #Excluindo o valor unitario da STACF

#Cálculo da STACF dos resíduos com parâmetros reais

stacf_res_table_r<-matrix(nrow=timelags_acf_res+1,ncol=n_vizinhancas)

for (i in 0:timelags_acf_res){
  for (j in 0:(n_vizinhancas-1)){
    if (j == 0){
      stacf_res_table_r[i+1,j+1] <- st.acf(residuos_cal_r,timelag=i) #k=0 e l=0
    }else{
      stacf_res_table_r[i+1,j+1] <- st.acf(residuos_cal_r,wmatrix1=W[[j+1]],timelag=i,lwmat=TRUE) #k=0 e l=1, 2 e 3 
    }
  }
}

stacf_res_table_r <- as.vector(stacf_res_table_r)
stacf_res_table_r <- stacf_res_table_r[2:length(stacf_res_table_r)]
############################

#Cálculo dos Indicadores de Acurácia com parâmetros estimados

acuracia <- coef_acur(observado = observado_cal,residuo = residuos_cal,stacf_res = stacf_res_table)
acuracia <- as.data.frame(acuracia)
colnames(acuracia) <- acuracia[1,]
acuracia <- acuracia[-1,]
rownames(acuracia) <- NULL

for (i in 1:4){
  acuracia[1,i] <- formatC(as.numeric(acuracia[1,i]),digits=3,format="e")
}

#Cálculo dos Indicadores de Acurácia com parâmetros reais

acuracia_r <- coef_acur(observado = observado_cal,residuo = residuos_cal_r,stacf_res = stacf_res_table_r)
acuracia_r <- as.data.frame(acuracia_r)
colnames(acuracia_r) <- acuracia_r[1,]
acuracia_r <- acuracia_r[-1,]
rownames(acuracia_r) <- NULL

for (i in 1:4){
  acuracia_r[1,i] <- formatC(as.numeric(acuracia_r[1,i]),digits=3,format="e")
}

acuracia_table <- matrix(nrow=3,ncol=5)
acuracia_table[2:3,1] <- c("Par_Est", "Par_real")
acuracia_table[1,] <- c("Tipo","E","RSS","MAE","Box Pierce")
acuracia_table[2,2:5] <- as.matrix(acuracia[1,])
acuracia_table[3,2:5] <- as.matrix(acuracia_r[1,])
acuracia_table <- as.data.frame(acuracia_table)
colnames(acuracia_table) <- acuracia_table[1,]
acuracia_table <- acuracia_table[-1,]

print(acuracia_table)
```

Note que:
 - O valor de E adequado é entre 0 e 1, sendo que quando for <0, o modelo está muito ruim, quando foi = 0 o modelo é equivalente a simplemente realizar a média, e quando foi =1, o modelo é perfeito;
 - Os valores de RSS e MAE devem ser minimizados;
 - E o valor de Box-Pierce serve como desempate entre os modelos. Seu valor deve ser localizado em uma tabela Chi-Quadrado.
 
# SIMULAÇÃO

Tendo o modelo definido (ordens e parâmetros), pode-se partir para a simulação. Para ela, é necessária a definição de uma nova função, STARIMA, que aplicar a equação do método, recalculando resíduos a cada timelag calculado:


```{r, echo=FALSE}
#DEFINIÇÃO DA FUNÇÃO STARIMA

STARIMA <- function(par, datamat, wmatrix, ordens, residuos, timelags_fut){
  # Recebe os parâmetros estimados, os dados temporal-espaciais, a lista de matrizes espaciais, as ordens espaciais e temporais do modelo, uma matriz de resíduos calculada pela RSTARIMA e o número de timelags futuros a serem previstos.
  #datamat e residuos no formato n x t

  #Pegando as ordens
  p <- ordens[1]
  lambda <- ordens[2]
  q <- ordens[3]
  m <- ordens[4]
  
  #Criando a matriz de parâmetros a partir do vetor fornecido
  if (q>0){
    alfas <- matrix(par[1:((m+1)*q)],ncol=(m+1), nrow=q) #par de 1 a [(m+1) * q]
  }
  
  if (p>0){
    betas <- matrix(par[((m+1)*q+1):length(par)],ncol=(lambda+1), nrow=p) #par de [(m+1) * q] até o final - total de lambda+1 * p
  }

  n_radares <- length(datamat[,1]) #Número de radares do banco de dados
  
  y <- matrix(0,nrow=n_radares, ncol=timelags_fut)

  for (t in 1:timelags_fut){
    tmax <- length(datamat[1,]) #Máximo número de timelags no banco de dados (É atualizado toda vez que é previsto um novo timelag)
    
    if (p>0){
      for (k in 1:p){
        for (l in 0:lambda){
          y[,t] <- y[,t] + betas[k,l+1] * (wmatrix[[l+1]] %*% datamat[,tmax-k+1])
        }
      }
    }
    
    if (q>0){
      for (k in 1:q){
        for (l in 0:m){
          y[,t] <- y[,t] - alfas[k,l+1] * (wmatrix[[l+1]] %*% residuos[,tmax-k+1])
        }
      }
    }
    
    #Adicionando o valor previsto ao conjunto de dados, para a previsão dos seguintes
    y_t <- t(y[,t])
    datamat_t <- t(datamat)
    datamat_t <- rbind(datamat_t,y_t)
    datamat <- t(datamat_t)
    
    #Cálculo do resíduo do valor previsto
    y_res <- y[,t]
    if (p>0){
      for (k in 1:p){
        for (l in 0:lambda){
          y_res <- y_res - betas[k,l+1] * (wmatrix[[l+1]] %*% datamat[,tmax-k+1])
        }
      }
    }
    
    if (q>0){
      for (k in 1:q){
        for (l in 0:m){
          y_res <- y_res + alfas[k,l+1] * (wmatrix[[l+1]] %*% residuos[,tmax-k+1])
        }
      }
    }
    
    #Adicionando o resíduo do valor previsto ao conjunto de resíduos, para a previsão dos seguintes
    y_res_t <- t(y_res)
    residuo_t <- t(residuos)
    residuo_t <- rbind(residuo_t,y_res_t)
    residuos <- t(residuo_t)
  }
  
  return (y)
}

```


Como anteriormente os dados foram diferenciados e tiveram a média retirada, a previsão só está completa após desfazer esses procedimentos. Isso é feito com a função:

```{r, echo=FALSE}
Integracao <- function(datamat, previsao, medias, n_diff){
  #Recebe os dados originais (antes da diferenciação e da retirada da média), os dados previstos pela STARIMA, uma lista com as médias, e o número de diferenciações realizadas
  #Dados originais e previsão no formato n x t
  
  tmax_prev <- length(previsao[1,]) #Máximo número de timelags na previsão
  tmax_data <- length(datamat[1,]) #Máximo número de timelags nos dados originais
  n_radares <- length(datamat[,1]) #Número de radares do banco de dados
  
  #Adição das médias retiradas
  for (i in 1:n_radares){
    previsao[i,] <- previsao[i,] + medias[i,]
  }
  
  #Integração
  if (n_diff > 0){
    for (i in 1:n_diff){
      for (j in 1:tmax_prev){
        if (j == 1){
          previsao[,j] <- datamat[,tmax_data] + previsao[,j]
        } else {
          previsao[,j] <- previsao[,j] + previsao[,j-1]
        }
      }
    }
  }
  
  return(previsao)
}
```


Definidas as funções que realizam a previsão (STARIMA e Integração), parte-se para a simulação:

```{r, echo=FALSE}
treino <- tdados.mat
teste <- tdados.mat_teste

#Cálculo dos resíduos usados na STARIMA
residuos <- matrix(RSTARIMA(par=par_est,datamat=tdados.mat,wmatrix=W,ordens=ordens),nrow=n_radares)

#Número de steps a frente do horário escolhido, para a previsão
steps <- as.integer(readline("Quantos timelags deseja prever? "))

#Aplicação da STARIMA para previsão
previsao <- STARIMA(par=par_est, datamat=tdados.mat, wmatrix=W, ordens=ordens, residuos=residuos, timelags_fut=steps)

#Integração dos dados
previsao <- Integracao(datamat=treino,previsao=previsao,media=medias, n_diff=0)

```

É possível também realizar a simulação step by step, isto é, atualizando os dados de treino com dados reais observados (vindos dos dados de teste) a cada timelag previsto:

```{r, echo=FALSE}
#Aplicação da STARIMA para previsão step by step (sbs)

treino_sbs <- treino
teste_sbs <- teste

previsao_sbs <- matrix(nrow=n_radares,ncol=steps)

medias <- matrix(nrow=n_radares,ncol=1)

for (i in 1:steps){#Cálculo a cada step
  treino_sbs_diff <- treino_sbs
  #Centralização 
  for (j in 1:n_radares){
    media <- mean(treino_sbs[j,])
    medias[j,1] <- media
    treino_sbs_diff[j,] <- treino_sbs_diff[j,] - medias[j,]
  } 
  
  #Cálculo dos resíduos usados na STARIMA
  residuos_sbs <- matrix(RSTARIMA(par=par_est,datamat=treino_sbs_diff,wmatrix=W,ordens=ordens),nrow=n_radares) #Cálculo dos resíduos
  
  previsao_sbs_1 <- STARIMA(par=par_est, datamat=treino_sbs_diff, wmatrix=W, ordens=ordens, residuos=residuos_sbs, timelags_fut=1) #Previsão de 1 step
  
  #Integração da previsão de 1 timelag
  previsao_sbs_1 <- Integracao(datamat=treino_sbs,previsao=previsao_sbs_1, media=medias, n_diff = 0)
  previsao_sbs[,i] <- t(previsao_sbs_1) #Armazenando a previsão na tabela
  
  #Juntando o comportamento de 1 timelag aos dados de treino_sbs
  treino_sbs <- as.data.frame(treino_sbs)
  treino_sbs <- rownames_to_column(treino_sbs,var="Radar")
  comp_sbs <- as.data.frame(teste_sbs[,i])
  comp_sbs <- rownames_to_column(comp_sbs,var="Radar")
  treino_sbs <- join(treino_sbs,comp_sbs,by="Radar")
  treino_sbs <- column_to_rownames(treino_sbs,var="Radar")
  colnames(treino_sbs) <- NULL
  treino_sbs <- as.matrix(treino_sbs)
  
}
```

Plotagem das previsões:

```{r, echo=FALSE}
#Necessário um tratamento dos dados para a plotagem:

#OBSERVAÇÕES PASSADAS
observacao_t <- t(treino)

#COMPORTAMENTO FUTURO
comportamento_plot <- t(teste)
comportamento_plot <- as.matrix(comportamento_plot[1:as.integer(steps),])
comportamento_plot <- rbind(observacao_t,comportamento_plot)
comportamento_plot <- as.data.frame(as.matrix(comportamento_plot))

#PREVISÃO NORMAL
#Transpondo os Dados da Previsão Normal
previsao_t <- t(previsao)
colnames(previsao_t) <- radares

#Juntando dados de previsão aos dados observados no passado:
previsao_plot <- rbind(observacao_t,previsao_t)
previsao_plot <- as.data.frame(as.matrix(previsao_plot))

#PREVISÃO STEP BY STEP
#Transpondo os Dados da Previsão Step by Step
previsao_sbs_t <- t(previsao_sbs)
colnames(previsao_sbs_t) <- radares

#Juntando dados de previsão aos dados observados no passado
previsao_sbs_plot <- rbind(observacao_t,previsao_sbs_t)
previsao_sbs_plot <- as.data.frame(as.matrix(previsao_sbs_plot))

#----------

#Cabeçalhos para os dados conjuntos
cabecalho_prev <- c()
cabecalho_comp <- c()
cabecalho_prev_sbs <- c()
for (i in 1:n_radares){
  cabecalho_prev[i] <- paste(radares[i],"Previsão",sep = "-")
  cabecalho_comp[i] <- paste(radares[i],"Comportamento",sep = "-")
  cabecalho_prev_sbs[i] <- paste(radares[i],"PrevisãoSBS",sep = "-")
}

colnames(previsao_plot) <- cabecalho_prev
previsao_plot <- rownames_to_column(previsao_plot,var="Timelags")
colnames(comportamento_plot) <- cabecalho_comp
comportamento_plot <- rownames_to_column(comportamento_plot,var="Timelags")
colnames(previsao_sbs_plot) <- cabecalho_prev_sbs
previsao_sbs_plot <- rownames_to_column(previsao_sbs_plot,var="Timelags")

# Junção de Todos os Dados para Plotagem
dados_plotagem <- join(comportamento_plot,previsao_plot, by="Timelags")
dados_plotagem <- join(dados_plotagem,previsao_sbs_plot, by="Timelags")
dados_plotagem <- dados_plotagem %>% mutate (Timelags = as.integer(Timelags))

dados_plotagem <- dados_plotagem[(length(dados_plotagem[,1])-1.1*steps):length(dados_plotagem[,1]),]


#PLOTAGEM

for (i in 1:n_radares){
  grafico_comp <- ggplot(data=dados_plotagem,aes(x=Timelags)) + labs(title=paste("Radar ", radares[i], "(p=",p,",lambda=",lambdap,"q=",q,",m=",lambdaq,")"), x="Timelags", y="Volume de Tráfego") + geom_line(aes(y = dados_plotagem[,i+1+2*n_radares],group=1,color="Previsão Step by Step"),lwd=1.2) + geom_line(aes(y = dados_plotagem[,i+1+n_radares],group=1,color="Previsão"),lwd=1.2) + geom_line(aes(y=dados_plotagem[,i+1],group=1,color="Comportamento Real"),lwd=1.2)  + theme_gray() + theme(plot.title=element_text(size=15, face="bold",hjust = 0.5))+theme(legend.title=element_blank(),axis.line = element_line(size = 0.5, colour = "gray")) + theme(legend.position="top") + scale_color_manual(values=c("skyblue3","salmon","seagreen"))
  print(grafico_comp)
}

```

Para efeitos de comparação, aqui realiza-se também o teste utilizando os parâmetros reais para a previsão:

```{r, echo=FALSE}
#PREVISÃO NORMAL
#Cálculo dos resíduos usados na STARIMA
residuos_r <- matrix(RSTARIMA(par=par_real,datamat=tdados.mat,wmatrix=W,ordens=ordens),nrow=n_radares)

#Aplicação da STARIMA para previsão
previsao_r <- STARIMA(par=par_real, datamat=tdados.mat, wmatrix=W, ordens=ordens, residuos=residuos_r, timelags_fut=steps)

#Integração dos dados
previsao_r <- Integracao(datamat=treino,previsao=previsao_r,media=medias, n_diff=0)

#################################################
#PREVISÃO STEP BY STEP
treino_sbs_r <- treino
teste_sbs_r <- teste

previsao_sbs_r <- matrix(nrow=n_radares,ncol=steps)

medias_r <- matrix(nrow=n_radares,ncol=1)

for (i in 1:steps){#Cálculo a cada step
  #Centralização 
  for (j in 1:n_radares){
    treino_sbs_diff_r <- treino_sbs_r
    media_r <- mean(treino_sbs_r[j,])
    medias_r[j,1] <- media_r
    treino_sbs_diff_r[j,] <- treino_sbs_diff_r[j,] - medias_r[j,]
  } 
  
  #Cálculo dos resíduos usados na STARIMA
  residuos_sbs_r <- matrix(RSTARIMA(par=par_real,datamat=treino_sbs_diff_r,wmatrix=W,ordens=ordens),nrow=n_radares) #Cálculo dos resíduos
  
  previsao_sbs_1_r <- STARIMA(par=par_real, datamat=treino_sbs_diff_r, wmatrix=W, ordens=ordens, residuos=residuos_sbs_r, timelags_fut=1) #Previsão de 1 step
  
  #Integração da previsão de 1 timelag
  previsao_sbs_1_r <- Integracao(datamat=treino_sbs_r,previsao=previsao_sbs_1_r, media=medias_r, n_diff = 0)
  previsao_sbs_r[,i] <- t(previsao_sbs_1_r) #Armazenando a previsão na tabela
  
  #Juntando o comportamento de 1 timelag aos dados de treino_sbs
  treino_sbs_r <- as.data.frame(treino_sbs_r)
  treino_sbs_r <- rownames_to_column(treino_sbs_r,var="Radar")
  comp_sbs_r <- as.data.frame(teste_sbs_r[,i])
  comp_sbs_r <- rownames_to_column(comp_sbs_r,var="Radar")
  treino_sbs_r <- join(treino_sbs_r,comp_sbs_r,by="Radar")
  treino_sbs_r <- column_to_rownames(treino_sbs_r,var="Radar")
  colnames(treino_sbs_r) <- NULL
  treino_sbs_r <- as.matrix(treino_sbs_r)
  
}
```

Plotagem:

```{r}

#PREVISÃO NORMAL
#Transpondo os Dados da Previsão Normal
previsao_t_r <- t(previsao_r)
colnames(previsao_t_r) <- radares

#Juntando dados de previsão aos dados observados no passado:
previsao_plot_r <- rbind(observacao_t,previsao_t_r)
previsao_plot_r <- as.data.frame(as.matrix(previsao_plot_r))

#PREVISÃO STEP BY STEP
#Transpondo os Dados da Previsão Step by Step
previsao_sbs_t_r <- t(previsao_sbs_r)
colnames(previsao_sbs_t_r) <- radares

#Juntando dados de previsão aos dados observados no passado
previsao_sbs_plot_r <- rbind(observacao_t,previsao_sbs_t_r)
previsao_sbs_plot_r <- as.data.frame(as.matrix(previsao_sbs_plot_r))

#----------

colnames(previsao_plot_r) <- cabecalho_prev
previsao_plot_r <- rownames_to_column(previsao_plot_r,var="Timelags")

colnames(previsao_sbs_plot_r) <- cabecalho_prev_sbs
previsao_sbs_plot_r <- rownames_to_column(previsao_sbs_plot_r,var="Timelags")

# Junção de Todos os Dados para Plotagem
dados_plotagem_r <- join(comportamento_plot,previsao_plot_r, by="Timelags")
dados_plotagem_r <- join(dados_plotagem_r,previsao_sbs_plot_r, by="Timelags")
dados_plotagem_r <- dados_plotagem_r %>% mutate (Timelags = as.integer(Timelags))

dados_plotagem_r <- dados_plotagem_r[(length(dados_plotagem_r[,1])-steps-10):length(dados_plotagem_r[,1]),]


#PLOTAGEM

for (i in 1:n_radares){
  grafico_comp <- ggplot(data=dados_plotagem_r,aes(x=Timelags)) + labs(title=paste("Radar ", radares[i], "(p=",p,",lambda=",lambdap,",q=",q,",m=",lambdaq,")"), x="Timelags", y="Volume de Tráfego") + geom_line(aes(y = dados_plotagem_r[,i+1+2*n_radares],group=1,color="Previsão Step by Step"),lwd=1.2) + geom_line(aes(y = dados_plotagem_r[,i+1+n_radares],group=1,color="Previsão"),lwd=1.2)  + geom_line(aes(y=dados_plotagem_r[,i+1],group=1,color="Comportamento Real"),lwd=1.2) + theme_gray() + theme(plot.title=element_text(size=15, face="bold",hjust = 0.5))+theme(legend.title=element_blank(),axis.line = element_line(size = 0.5, colour = "gray")) + theme(legend.position="top") + scale_color_manual(values=c("skyblue3","salmon","seagreen"))
  print(grafico_comp)
}
```

# ANÁLISE DAS SIMULAÇÕES

Cálculo de MAE para as previsões:

```{r,echo=FALSE}
comportamento <- teste[,1:as.integer(steps)]

MAE_v <- sum(abs(comportamento - previsao))/length(comportamento)

MAE_v_sbs <- sum(abs(comportamento - previsao_sbs))/length(comportamento)

MAE_v_r <- sum(abs(comportamento - previsao_r))/length(comportamento)

MAE_v_sbs_r <- sum(abs(comportamento - previsao_sbs_r))/length(comportamento)

print(paste("MAE da Previsão Padrão:", round(MAE_v,digits=4)))
print(paste("MAE da Previsão Padrão com Parâmetros Reais:", round(MAE_v_r,digits=4)))
print(paste("MAE da Previsão Step by Step:", round(MAE_v_sbs,digits=4)))
print(paste("MAE da Previsão Step by Step com Parâmetros Reais:", round(MAE_v_sbs_r,digits=4)))
```
```{r, echo=FALSE}
print(acuracia_table)
```


É importante uma análise do erro relativo também ao longo do tempo:

```{r, echo=FALSE}
#Erro Previsão Normal Parâmetros Estimados
erro <- matrix(nrow=steps, ncol=n_radares)
for (i in 1:n_radares){
  erro[,i] <- abs(comportamento[i,] - previsao[i,])
}

erro_plot <- as.data.frame(erro)
colnames(erro_plot) <- radares
erro_plot <- rownames_to_column(erro_plot,var="Timelags")
erro_plot <- erro_plot %>% mutate(Timelags = as.integer(Timelags))

#Erro Previsão Step by Step Parâmetros Estimados
erro_sbs <- matrix(nrow=steps, ncol=n_radares)
for (i in 1:n_radares){
  erro_sbs[,i] <- abs(comportamento[i,] - previsao_sbs[i,])
}

erro_sbs_plot <- as.data.frame(erro_sbs)
colnames(erro_sbs_plot) <- radares
erro_sbs_plot <- rownames_to_column(erro_sbs_plot,var="Timelags")
erro_sbs_plot <- erro_sbs_plot %>% mutate(Timelags = as.integer(Timelags))

#Erro Previsão Normal Parâmetros Reais
erro_r <- matrix(nrow=steps, ncol=n_radares)
for (i in 1:n_radares){
  erro_r[,i] <- abs(comportamento[i,] - previsao_r[i,])
}

erro_plot_r <- as.data.frame(erro_r)
colnames(erro_plot_r) <- radares
erro_plot_r <- rownames_to_column(erro_plot_r,var="Timelags")
erro_plot_r <- erro_plot_r %>% mutate(Timelags = as.integer(Timelags))

#Erro Previsão Step by Step Parâmetros Reais
erro_sbs_r <- matrix(nrow=steps, ncol=n_radares)
for (i in 1:n_radares){
  erro_sbs_r[,i] <- abs(comportamento[i,] - previsao_sbs_r[i,])
}

erro_sbs_plot_r <- as.data.frame(erro_sbs_r)
colnames(erro_sbs_plot_r) <- radares
erro_sbs_plot_r <- rownames_to_column(erro_sbs_plot_r,var="Timelags")
erro_sbs_plot_r <- erro_sbs_plot_r %>% mutate(Timelags = as.integer(Timelags))
```

Plotagem dos erros relativos para as quatro simulações (Normal e Step by Step, com os parâmetros reais e estimados):

```{r,echo=FALSE}
cabecalho_res_sbs <- c()
cabecalho_res_norm <- c()
cabecalho_res_sbs_r <- c()
cabecalho_res_norm_r <- c()
for (i in 1:n_radares){
  cabecalho_res_sbs[i] <- paste0(radares[i],"SBS_Est",sep="-")
  cabecalho_res_norm[i] <- paste0(radares[i],"NRM_Est",sep="-")
  cabecalho_res_sbs_r[i] <- paste0(radares[i],"SBS_Real",sep="-")
  cabecalho_res_norm_r[i] <- paste0(radares[i],"NRM_Real",sep="-")
}

colnames(erro_plot) <- c("Timelags",cabecalho_res_norm)
colnames(erro_sbs_plot) <- c("Timelags",cabecalho_res_sbs)
colnames(erro_plot_r) <- c("Timelags",cabecalho_res_norm_r)
colnames(erro_sbs_plot_r) <- c("Timelags",cabecalho_res_sbs_r)

erro_rel <- join(erro_plot,erro_sbs_plot,by="Timelags")
erro_rel <- join(erro_rel,erro_plot_r,by="Timelags")
erro_rel <- join(erro_rel,erro_sbs_plot_r,by="Timelags")

cores <- hcl.colors(4, palette = "viridis", alpha = NULL, rev = FALSE, fixup = TRUE)

for (i in 1:n_radares){
  grafico_erro <- ggplot(data=erro_rel,aes(x=Timelags)) + labs(title = paste0("Erro Absoluto ao Longo do Tempo - ",radares[i]), x="Timelags", y="Erro Absoluto") + geom_line(aes(y = erro_rel[,i+1],group=1,color=" Normal Par. Est.",linetype=' Normal Par. Est.'),lty=2,lwd=1.03) + geom_line(aes(y = erro_rel[,i+1+n_radares],group=1,color=" Step by Step Par. Est.",linetype=' Step by Step Par. Est.'),lty=1,lwd=1.03) + geom_line(aes(y = erro_rel[,i+1+n_radares*2],group=1,color=" Normal Par. Real",linetype=' Normal Par. Real'),lty=1,lwd=1.03) + geom_line(aes(y = erro_rel[,i+1+n_radares*3],group=1,color=" Step by Step Par. Real",linetype=' Step by Step Par. Real'),lty=1,lwd=1.03) + theme_gray() + theme(plot.title=element_text(size=15, face="bold",hjust = 0.5))+theme(legend.title=element_blank(),axis.line = element_line(size = 0.5, colour = "lightgray"),legend.position="top",legend.key.size = unit(1.5,"line")) + scale_color_manual(values=cores)
  print(grafico_erro)
}

```

Isso encerra os testes necessários para se construir o modelo STARIMA completo.
